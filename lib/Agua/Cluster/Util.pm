package Agua::Cluster::Util;
use Moose::Role;
use Moose::Util::TypeConstraints;

use Data::Dumper;



use lib "..";
use Sampler;

=head2

	SUBROUTINE		loop

	PURPOSE
print Dumper ;	  
        CONVERT AN ARGUMENT OF THE FORM "1-3,five,six" INTO

		AN ARRAY OF THE FORM [1,2,3,"five","six"]

=cut
sub stringToArray {
	my $self	=	shift;
	my $string	=	shift;

	my $array;
	if ( $string =~ /^(\d+)\-(\d+)$/ )
	{
		my $start = $1;
		my $end = $2;
		for my $time ( $start .. $end )
		{
			push @$array, $time;
		}
	}
	else
	{
		@$array = split ",", $string;

		for ( my $i = 0; $i < @$array; $i++ )
		{
			my $replicate = $$array[$i];
			if ( $replicate =~ /^(\d+)\-(\d+)$/ )
			{
				splice @$array, $i, 1;
				$i--;
				my $start = $1;
				my $end = $2;
				for my $time ( $start .. $end )
				{
					push @$array, $time;
					$i++;
				}
			}
		}
	}

	return $array;
}

=head2

	SUBROUTINE     chromosomeSizes

    PURPOSE

        CALCULATE CHROMOSOME SIZES AND PRINT TO FILE

    INPUT

        1. FULL PATH TO DIRECTORY CONTAINING FASTA FILES

		2. [optional] REFERENCE FILE SUFFIX (DEFAULT = .fa)

    OUTPUT

        1. OUTPUT FILE IN INPUT DIRECTORY: chromosome-sizes.txt 

		2. FILE CONTAINS THESE COLUMNS: 

            chromosome  start   stop    length

=cut

sub chromosomeSizes {
	my $self		=	shift;
	my $directory	=	shift;
	my $suffix		=	shift;

	#### CHECK FOR OUTPUT DIRECTORY
	print "Agua::Cluster::Util::chromosomeSizes    directory not defined: $directory\n" if not defined $directory or not $directory;
	print "Agua::Cluster::Util::chromosomeSizes    directory is '': $directory\n" if not defined $directory;
	print "Agua::Cluster::Util::chromosomeSizes    Can't find directory: $directory\n" if not -d $directory;

	#### GET REFERENCE FASTA FILES	
	$suffix = "*.fa" if not defined $suffix;
	my $files = $self->listFiles($directory, $suffix);

	#### SORT FILES BY NUMBER
	@$files = Util::sort_naturally(\@$files);

	#### CHDIR TO OUTPUT DIRECTORY
	chdir($directory) or die "Could not CHDIR to directory: $directory\n";

	#### OPEN OUTPUT FILE
	my $outputfile = "$directory/chromosome-sizes.txt";
	open(OUTFILE, ">$outputfile") or die "Can't open output file: $outputfile\n";

	#### GO THROUGH FASTA FILES
	my $file_sizes;
	my $start = 0;
	my $stop = 0;
	foreach my $file ( @$files )
	{
		if ( not -f $file )
		{
			print "File not found: $directory/$file\n";
			exit;
		}

		open(FILE, $file);
		$/ = "END OF FILE";
		my $contents = <FILE>;
		close(FILE);
		my $total_length = length($contents);
		my $header = `grep ">" $file`;
		$header =~ s/\s+$//;
		my $header_length = length($header);
		$header =~ s/^>//;
		$total_length = $total_length - $header_length;

		#### SET stop
		$stop = $start + $total_length;

		#### PRINT TO OUTFILE    
		print OUTFILE "$header\t$start\t$stop\t$total_length\n";
		print "$header\t$start\t$stop\t$total_length\n";

		#### SET start
		$start = $stop + 1;
	}

	#### CLOSE OUTPUT FILE AND REPORT
	close(OUTFILE);
	print "Agua::Cluster::Util::chromosomeSizes    Output file printed:\n\n$outputfile\n\n";
}


=head2

	SUBROUTINE		getFilenames

	PURPOSE

		RETURN AN ARRAY OF FILE NAMES GIVEN THEIR FULL PATHS

=cut
sub getFilenames {
	my $self		=	shift;
	my $filepaths	=	shift;



	my $filenames = [];
	foreach my $filepath ( @$filepaths )
	{
		my ($filename) = $filepath =~ /^.+?\/([^\/]+)$/;
		push @$filenames, $filename if defined $filename;
		print "filename not defined for filepath: $filepath\n" if not defined $filename;
	}

	return $filenames;	
}

=head2

	SUBROUTINE		subfiles

	PURPOSE

		RETURN AN ARRAY OF SAM FILES GENERATED BY TOPHAT ALIGNMENT 

		BASED ON THE OUTPUT DIRECTORY, REFERENCE AND SPLIT FILES

=cut

sub subfiles {
	my $self		=	shift;
	my $outputdir	=	shift;
	my $reference	=	shift;
	my $splitfiles	=	shift;
	my $filename	=	shift;


	#### USE TOPHAT accepted_hits.sam AS DEFAULT
	$filename = "accepted_hits.sam" if not defined $filename;


	my $subfiles = [];
	foreach my $splitfile ( @$splitfiles )
	{
		##### GET SPLITFILE NUMBER
		my ($splitnumber) = $$splitfile[0] =~ /(\d+)\/[^\/]+$/;	

		##### SET OUTPUT DIR TO SUBDIRECTORY CONTAINING SPLITFILE
		my $outdir = "$outputdir/$reference/$splitnumber";

		#### NAME OUTPUT DIR AFTER REFERENCE FILE
		my $samfile = "$outdir/$filename";
		push @$subfiles, $samfile;
	}

	return $subfiles;
}


=head2

	SUBROUTINE		listReferenceSubdirs

	PURPOSE

		RETURN A LIST OF SUBDIRS GIVEN A PARENT DIRECTORY

=cut

sub listReferenceSubdirs {
	my $self			=	shift;
	my $referencedir	=	shift;

	print "Agua::Cluster::Util::listReferenceSubdirs    referencedir not defined\n" and exit if not defined $referencedir;

	#### GET SUBDIRS
	chdir($referencedir) or die "Can't change to reference directory: $referencedir\n";
	my $subdirs = Util::directories($referencedir);
	print "Agua::Cluster::Util::listReferenceSubdirs    Quitting because no subdirs found in directory: $referencedir\n" and exit if scalar(@$subdirs) == 0;

	#### SORT SUBDIRS BY NUMBER
	@$subdirs = Util::sort_naturally(\@$subdirs);

	#### DEBUG - REVERSE SUBDIRS, SO THAT SMALLEST CHROMOSOMES ARE FIRST
	@$subdirs = reverse @$subdirs;

	return $subdirs;
}


=head2

	SUBROUTINE		listReferenceFiles

	PURPOSE

		RETURN A LIST OF FILES IN A DIRECTORY CORRESPONDING

		TO THE SUPPLIED PATTERN

=cut

sub listReferenceFiles {
	my $self			=	shift;
	return $self->listFiles( @_ );
}

=head2

	SUBROUTINE		listFiles

	PURPOSE

		RETURN A LIST OF FILES IN A DIRECTORY CORRESPONDING

		TO THE SUPPLIED PATTERN

=cut

sub listFiles {
	my $self		=	shift;
	my $directory	=	shift;
	my $pattern		=	shift;


	#### CHECK INPUTS
	print "Agua::Cluster::Util::listFiles    directory not defined\n" and exit if not defined $directory;
	print "Agua::Cluster::Util::listFiles    pattern not defined\n" and exit if not defined $pattern;

	#### GET REFERENCE FILES
	chdir($directory) or die "Can't change to reference directory: $directory\n";
	my $files;
	@$files = <$directory/$pattern>;
	return if not defined $files;

	#### RETURN EMPTY ARRAY IF NO FILES
	print "Agua::Cluster::Util::listFiles    No files found in directory: $directory\n" if scalar(@$files) == 0;
	return [] if scalar(@$files) == 0;

	#### SORT BY NUMBER
	$files = Util::sort_naturally($files);

	return $files;
}



=head2

	SUBROUTINE		checkFiles

	PURPOSE

		CHECK INPUT FILES ARE ACCESSIBLE AND NON-EMPTY

=cut

sub checkFiles {
	my $self		=	shift;
	my $files		=	shift;

	#### SANITY CHECK
	foreach my $file ( @$files )
	{
		if ( not -f $file )
		{
			print "Agua::Cluster::Util::::alignmentCommands    Can't find file: $file\n";
			exit;
		}
		if ( -z $file )
		{
			print "Agua::Cluster::Util::::alignmentCommands     File is empty: $file\n";
			exit;
		}
	}
}


=head2

	SUBROUTINE		splitfileChunks

	PURPOSE

		LIMIT INPUT FILES TO SPECIFIED CHUNKS OF THE SPLIT FILE LIST

=cut

sub splitfileChunks {
	my $self		=	shift;	
	my $splitfiles	=	shift;
	my $chunks		=	shift;



	my $new_splitfiles = [];
	my @groups = split ",", $chunks;
	foreach my $groupstring ( @groups )
	{
		if ( $groupstring =~ /^(\d+)$/ )
		{
			push @$new_splitfiles, $$splitfiles[$1 - 1];
		}
		elsif ( $groupstring =~ /^(\d+)\-(\d+)$/ )
		{
			for my $index ( $1..$2 )
			{
				push @$new_splitfiles, $$splitfiles[$index - 1];
			}
		}
	}

	return $new_splitfiles;
}







=head2


	SUBROUTINE		splitfiles

	PURPOSE

		1. RETURN THE LIST OF SPLITFILE PATHS

=cut

sub getSplitfiles {
	my $self		=	shift;
	my $splitfile	=	shift;



	print "Agua::Cluster::Util::splitfiles    splitfile: $splitfile\n";


	return $self->splitfiles() if defined $self->splitfiles();

	return Sampler::splitfiles($splitfile);
}



=head2


	SUBROUTINE		doSplitfiles

	PURPOSE

		1. SPLIT UP THE INPUT FILES INTO SMALLER 'SPLIT FILES' 

			CONTAINING A USER-SPECIFIED NUMBER OF READS

		2. RETURN THE LIST OF SPLITFILE PATHS

=cut

sub doSplitfiles {
	my $self		=	shift;
	my $splitfile	=	shift;
	my $label		=	shift;
	my $inputfiles	=	shift;
	my $matefiles	=	shift;
	my $outputdir	=	shift;
	my $maxlines	=	shift;
	my $clean		=	shift;


	#### CHECK label IS DEFINED (REQUIRED FOR LATER FINDING SPLITFILES BY NUMBER AND LABEL)
	print "Agua::Cluster::Util::doSplitfiles    label not defined. Exiting\n" and exit if not defined $label;
	print "Agua::Cluster::Util::doSplitfiles    splitfile not defined. Exiting\n" and exit if not defined $splitfile;

	#### FILES AND DIRS	
	$outputdir 		=	$self->outputdir() if not defined $outputdir;
	$inputfiles 		=	$self->inputfiles() if not defined $inputfiles;
	$matefiles 		=	$self->matefiles() if not defined $matefiles;

	#### SPLIT FILES
	$maxlines 		=	$self->maxlines() if not defined $maxlines;
	$clean 			=	$self->clean() if not defined $clean;

	#### SET SUFFIX FOR Sampler::splitFiles
	#### (SUFFIX OF LAST COMMA-SEPARATED INPUT FILE)
	my ($suffix) = $self->fileSuffix($inputfiles);


	my $splitfiles;
	if ( (defined $clean and $clean) or not -f $splitfile or -z $splitfile )
	{
		$splitfiles = Sampler::splitFiles(
			{
				'inputfiles' 	=> 	$inputfiles,
				'matefiles' 	=> 	$matefiles,
				'lines'			=> 	$maxlines,
				'splitfile'		=>	$splitfile,
				'outputdir'		=>	$outputdir,
				'label'			=>	$label,
				'suffix'		=> 	$suffix
			}
		);	
	}
	else
	{
		$splitfiles = Sampler::get_splitfiles($splitfile);
	}

	$self->{splitfiles} = $splitfiles;

	#### SANITY CHECK
	print "Agua::Cluster::Util::doSplitfiles    No splitfiles. Exiting\n" and exit if not defined $splitfiles or scalar(@$splitfiles) == 0;

	return $splitfiles;	
}


sub copySplitfiles {
	my $self		=	shift;
	my $source	=	shift;
	my $target	=	shift;
	my $mode	=	shift;

	#### CHECK FOR OUTPUT DIRECTORY
	print "Agua::Cluster::Util::copySplitfiles    source not defined: $source\n" and exit if not defined $source;
	print "Agua::Cluster::Util::copySplitfiles    target not defined: $target\n" and exit if not defined $target;
	print "Agua::Cluster::Util::copySplitfiles    Can't find source: $source\n" and exit if not -d $source;

	#### CREATE TARGET DIR
	File::Path::mkpath($target) if not -d $target;

	#### SET TARGET NAME TO SECOND FROM TOP DIRECTORY
	my ($targetname) = $target =~ /([^\/]+)\/[^\/]+$/;

	#### CHDIR TO OUTPUT DIRECTORY
	chdir($source) or die "Could not CHDIR to source: $source\n";

	my $targetpath = $target;
	File::Path::mkpath($targetpath);
	print "Can't make targetpath: $targetpath\n" if not -d $targetpath;

	#### FORMAT:
	#### 0       0       /scratch/syoung/base/pipeline/SRA/NA18507/SRP000239/sampled/200bp/chr22/bowtie/1/1/bowtie-1_1.1.txt
	my $sourcesplitfile = "$source/splitfile.txt";
	my $targetsplitfile = "$target/splitfile.txt";
	open(OUT, ">$targetsplitfile") or die "Can't open targetsplitfile: $targetsplitfile\n";

	open(FILE,$sourcesplitfile) or die "Can't open sourcesplitfile: $sourcesplitfile\n";
	my @lines = <FILE>;
	close(FILE);
	foreach my $line ( @lines )
	{
		next if $line =~ /^\s*$/;

		my ($pairinfo, $sourcepath, $number, $sourcename, $suffix) = $line =~ /^(\d+\s+\d+\s+)(\S+\D+)(\d+)\/([^\/]+)(-\d+_\d+.\d+.txt)$/;

		File::Path::mkpath("$targetpath/$number");
		print "Exiting because can't make targetpath: $targetpath\n" and exit if not -d $targetpath;

		my $sourcefile = "$sourcepath$number/$sourcename$suffix";
		my $targetfile = "$targetpath/$number/$targetname$suffix";

		my $targetline = "$pairinfo$targetfile";
		print OUT $targetline, "\n";

		#### COPY OR LINK
		if ( $mode eq "copy" )
		{
			my $command = "cp -f $sourcefile $targetfile";
			`$command`;
		}
		elsif ( $mode eq "link" )
		{
			my $command = "rm -fr $targetfile; ln -s $sourcefile $targetfile";
			`$command`;
		}
		else
		{
			print "mode not supported: $mode\n";
			exit;
		}
	}

	close(OUT) or die "Can't close targetsplitfile: $targetsplitfile\n";
}


=head2

	SUBROUTINE		fileSuffix

	PURPOSE

		1. RETURN THE 1 TO 5-LETTER SUFFIX OF A FILE IF EXISTS

		2. RETURN SUFFIX OF LAST INPUT FILE IF COMMA-SEPARATED 

=cut

sub fileSuffix { 
	my $self		=	shift;
	my $filename	=	shift;


	return $filename =~ /(\.[^\.]{1,5})$/;
}


=head

	SUBROUTINE 		copyFiles

	PURPOSE

		MOVE NUMERIC DIRECTORIES

=cut

sub copyFiles {
	my $self		=	shift;
	my $source		=	shift;
	my $target		=	shift;
	my $filename	=	shift;
	my $mode		=	shift;
	my $directory	=	shift;


	#### CHECK INPUTS
	print "Agua::Cluster::Util::copyFiles    mode not supported (subdirs|archive|delete) (Use --help for usage)\n" and exit if defined $mode and $mode !~ /^(name|regex)$/;
	print "Agua::Cluster::Util::copyFiles    source not defined: $source\n" if not defined $source or not $source;
	print "Agua::Cluster::Util::copyFiles    Can't find source: $source\n" if not -d $source;
	print "Agua::Cluster::Util::copyFiles    target not defined: $target\n" if not defined $target or not $target;
	print "Agua::Cluster::Util::copyFiles    Can't find target: $target\n" if not -d $target;
	print "Agua::Cluster::Util::copyFiles    mode not defined: $filename\n" if not defined $filename or not $filename;

	if ( not defined $mode or $mode =~ /^name$/ )
	{
		print "Agua::Cluster::Util::copyFiles    Running search by name: $filename\n";

		my @files = split "," , $filename;
		foreach my $file ( @files )
		{
			my $sourcefile = "$source/$file";
			print "Agua::Cluster::Util::copyFiles    Can't find sourcefile: $sourcefile\n" and next if not -f $sourcefile and not defined $directory;
			print "Agua::Cluster::Util::copyFiles    Can't find sourcefile: $sourcefile\n" and next if not -d $sourcefile and defined $directory;

			File::Path::mkpath($target) if not -d $target;
			print "Agua::Cluster::Util::copyFiles    Can't create target: $target\n" if not -d $target;

			my $command = "cp -r $sourcefile $target";
			print "Agua::Cluster::Util::copyFiles    command: $command\n";
			print `$command`;
		}
	}
	elsif ( $mode =~ /^regex$/ )
	{
		opendir(DIR, $source) or die "Can't open source directory: $source\n";
		my @foundfiles = readdir(DIR);
		close(DIR);

		foreach my $foundfile ( @foundfiles )
		{
			print "Agua::Cluster::Util::copyFiles    foundfile is not a file: $foundfile. Skipping\n"
				and next if -d $foundfile and not defined $directory;
			print "Agua::Cluster::Util::copyFiles    foundfile is a file: $foundfile. Skipping\n"
				and next if -f $foundfile and defined $directory;
			my @patterns = split "," , $filename;
			foreach my $pattern ( @patterns )
			{
				use re 'eval';		# EVALUATE $pattern AS REGULAR EXPRESSION

				if ( $foundfile =~ /$pattern/ )
				{
					my $command = "cp-r  $source/$foundfile $target";
					print "Agua::Cluster::Util::copyFiles    command: $command\n";
					print `$command`;
				}

				no re 'eval';		# STOP EVALUATING AS REGULAR EXPRESSION
			}
		}
	}
}


=head

	SUBROUTINE 		moveDirs

	PURPOSE

		MOVE NUMERIC OR ALPHABETIC DIRECTORIES

=cut

sub moveDirs {
	my $self		=	shift;
	my $source		=	shift;
	my $target		=	shift;
	my $mode		=	shift;

	#### CHECK FOR OUTPUT DIRECTORY
	print "Agua::Cluster::Util::moveDirs    source not defined: $source\n" if not defined $source or not $source;
	print "Agua::Cluster::Util::moveDirs    Can't find source: $source\n" if not -d $source;
	print "Agua::Cluster::Util::moveDirs    target not defined: $target\n" if not defined $target or not $target;
	print "Agua::Cluster::Util::moveDirs    Can't find target: $target\n" if not -d $target;
	print "Agua::Cluster::Util::moveDirs    mode not defined: $mode\n" if not defined $mode or not $mode;

	#### CHDIR TO OUTPUT DIRECTORY
	chdir($source) or die "Could not CHDIR to source: $source\n";
	opendir(DIR, $source) or die "Can't open source: $source\n";
	my @subdirs = readdir(DIR);
	close(DIR);
	for ( my $i = 0; $i < @subdirs; $i++ )
	{
		my $subdir = "$source/$subdirs[$i]";
		splice @subdirs, $i, 1 if not -d $subdir;
		$i-- if not -d $subdir;
	}
	print "subdirs: @subdirs\n";

	foreach my $subdir ( @subdirs )
	{
		next if not $subdir =~ /^\d+$/;
		print "subdir: $subdir\n";

		my $command = "mv $source/$subdir $target";
		print "Agua::Cluster::Util::moveDirs    command: $command\n";
		print `$command`;
	}
}


1;
