package CUFFCOMPARE;


=head2

		PACKAGE		CUFFCOMPARE

		VERSION		0.02

		PURPOSE

	        WRAPPER SCRIPT FOR RUNNING CUFFCOMPARE EXPRESSION ANALYSIS

		HISTORY
					0.02 ADDED CHUNK-BY-CHROMOSOME IF referencedir SPECIFIED
						AND RUN CUFFCOMPARE COMMAND
					0.01 BASIC VERSION
=cut

use strict;
use warnings;
use Carp;

require Exporter;
our @ISA = qw(Exporter Cluster);
#our @EXPORT_OK = qw();
our $AUTOLOAD;

#### INTERNAL MODULES
use Cluster;
use Util;
use Sampler;

#### EXTERNAL MODULES
use Data::Dumper;
use File::Path;
use File::Remove;
#use MD5;

#### SET SLOTS
our @DATA = qw(

DISTANCE
SPLITFILE
INPUTDIR
OUTPUTDIR
DISTANCE
REFERENCE
MAXLINES
CHUNKS
BATCHSTATS

PARAMS
LABEL
GTF
KEEP

CUFFCOMPARE
BOWTIE
CUFFCOMPARE
SAMTOOLS
SAMTOOLSINDEX

CLUSTER
QUEUE
QSTAT
MAXJOBS
CPUS
SLEEP
VERBOSE
DOT
QSUB
);
our $DATAHASH;
foreach my $key ( @DATA )	{	$DATAHASH->{lc($key)} = 1;	}


#=head2
#
#	SUBROUTINE		samfiles
#	
#	PURPOSE
#	
#		RETURN AN ARRAY OF SAM FILES GENERATED BY CUFFCOMPARE ALIGNMENT 
#		
#		BASED ON THE OUTPUT DIRECTORY, REFERENCE AND SPLIT FILES
#
#=cut
#
#sub samfiles
#{
#	my $self		=	shift;
#	my $outputdir	=	shift;
#	my $referencefile	=	shift;
#	my $splitfiles	=	shift;
#	
#	my $samfiles = [];
#	foreach my $splitfile ( @$splitfiles )
#	{
#		##### GET SPLITFILE NUMBER
#		my ($splitnumber) = $$splitfile[0] =~ /(\d+)\/[^\/]+$/;	
#
#		##### SET OUTPUT DIR TO SUBDIRECTORY CONTAINING SPLITFILE
#		my $outdir = "$outputdir/$referencefile/$splitnumber";
#		
#		#### NAME OUTPUT DIR AFTER REFERENCE FILE
#		my $samfile = "$outdir/accepted_hits.sam";
#		push @$samfiles, $samfile;
#	}
#	
#	return $samfiles;
#}




=head2

	SUBROUTINE		run

	PURPOSE

		CREATE .sh FILE

=cut

sub run
{
	my $self			=	shift;



	#### GET VARIABLES:

	#### RUN LOCALLY OR ON CLUSTER
	my $cluster = $self->get_cluster();

	#### DO MULTIPLE REFERENCES IN PARALLEL
	my $reference = $self->get_reference();

	#### LIMIT INPUTFILES TO SPECIFIC CHUNKS
	my $chunks = $self->get_chunks();

	#### FILES AND DIRS	
	my $inputdir 		=	$self->get_inputdir();
	my $outputdir 		=	$self->get_outputdir();
	my $duration;


	#### GET REFERENCE FILES
	chdir($reference) or die "Can't change to reference directory: $reference\n";
	my @referencefiles = <*rev.1.ebwt>;
	print "CUFFCOMPARE::run    Quitting because no files found in directory: $reference\n" and exit if scalar(@referencefiles) == 0;

	#### TRUNCATE REFERENCE FILES TO CREATE CORRECT STUB IDENTIFIER
	foreach my $referencefile ( @referencefiles )
	{
		$referencefile =~ s/\.rev\.1\.ebwt$//;
	}

	#### SORT BY NUMBER
	@referencefiles = Util::sort_naturally(\@referencefiles);

	#### SMALLEST CHROMOSOMES FIRST
	@referencefiles = reverse @referencefiles;
	print "referencefiles: @referencefiles\n";

	#### SET NAME OF FILE CONTAINING LIST OF SPLITFILES 
	my $splitfile = $self->get_splitfile();
	if ( not defined $splitfile or not $splitfile )
	{
		$splitfile = "$outputdir/splitfiles";
		$self->set_splitfile($splitfile);
	}
	my $splitfiles = Sampler::get_splitfiles($splitfile);
	print "CUFFCOMPARE::run    No splitfiles produced. Quitting\n" and exit if not defined $splitfiles or scalar(@$splitfiles) == 0;

	#### LIMIT INPUT FILES TO SPECIFIED CHUNKS IF DEFINED
	$splitfiles = $self->splitfileChunks($splitfiles, $chunks) if defined $chunks;

	#### GET LABEL TO USE GENERATING JOB FILES (stdoutfile, ETC.)
	my $label = $self->get_label();

	#### IF chunks IS DEFINED: 
	####
	#### 	1. FOR EACH REFERENCE SEQUENCE MERGE accepted_hits.bam 
	####
	####		FILES DEFINED IN chunks INTO A SINGLE BAM FILE
	####
	#### 	2. CONVERT SINGLE BAM FILE INTO A SAM FILE
	####
	####
	if ( defined $chunks )
	{
		#### 	1. MERGE BAM FILES INTO A SINGLE BAM FILE
		# samtools merge out.bam in1.bam in2.bam in3.bam
		# 		AND SORT THE BAM FILE, in preparation for SNP calling
		# samtools sort ec_snp.bam ec_snp.sorted

		my $samtools = $self->get_samtools();
		my $samtools_index = $self->get_samtoolsindex();

		my $mergebam_jobs = [];
		foreach my $referencefile ( @referencefiles )
		{
			#### GET SAM FILES
			my $bamfiles = $self->subfiles($inputdir, $referencefile, $splitfiles, "accepted_hits.bam");

			#### SET SINGLE BAM FILE AND SORTED SINGLE BAM FILE FOR THIS REFERENCE	
			my $bamfile = "$inputdir/$referencefile/accepted_hits.bam";
			my $unsorted_bamfile = "$outputdir/$referencefile/accepted_hits.unsorted.bam";

			#### CREATE OUTPUT DIRECTORY
			my $commands;
			push @$commands , "mkdir -p $outputdir/$referencefile";

			my $merge = sub {
				my $outfile		=	shift;
				my $tempfile	=	shift;
				my $subfile		=	shift;

				#### MERGE BAM FILES
				my $samtools = $self->get_samtools();

				return "$samtools/samtools merge $outfile $tempfile $subfile";
			};

			#### GET CUMULATIVE MERGE COMMANDS
			my $merge_commands = $self->cumulativeMergeCommands($bamfiles, $unsorted_bamfile, $merge);

			#### ADD MERGES TO COMMANDS 
			(@$commands) = (@$commands, @$merge_commands);

			# SORT THE BAM FILE
			# samtools sort ec_snp.bam ec_snp.sorted
			my $bamfile_stub = "$outputdir/$referencefile/accepted_hits.bam";
			$bamfile_stub =~ s/\.bam$//;
			my $sort_command = "$samtools/samtools sort $unsorted_bamfile $bamfile_stub";
			push @$commands, $sort_command;

			my $label = "mergebam-$referencefile";
			my $outdir = "$outputdir/$referencefile";

			my $job = $self->setJob($commands, $label, $outdir);

			push @$mergebam_jobs, $job;			
		}


		#### RUN MERGE JOBS
		$self->runJobs($mergebam_jobs, 'MERGEBAM');

		$duration = $self->lastDuration();

		#### 	3. CONVERT SINGLE BAM FILE INTO A SAM FILE
		my $bam2sam_jobs = [];
		# samtools view -o out.sam in.bam 
		foreach my $referencefile ( @referencefiles )
		{
			my $bamfile = "$outputdir/$referencefile/accepted_hits.bam";
			my $samfile = "$outputdir/$referencefile/accepted_hits.sam";
			my $command = "$samtools/samtools view -o $samfile $bamfile";

			my $label = "bam2sam-$referencefile";
			my ($outputdir) = $bamfile =~ /^(.+)\/[^\/]+$/; 

			my $job = $self->setJob([$command], $label, $outputdir);

			push @$bam2sam_jobs, $job;
		}

	#### UNCOMMENT


		#### RUN CONVERSION JOBS
		$self->runJobs($bam2sam_jobs);	

		$duration = $self->lastDuration();
		print "CUFFCOMPARE::run    ", Timer::current_datetime(), "    $duration    Completed converting from BAM to SAM files\n";


		#### RUN CUFFCOMPARE ON THE MERGED SAM FILE FOR EACH REFERENCE
		#### TO GET EXPRESSION CALCULATIONS.
		print "CUFFCOMPARE::run    Before run CUFFCOMPARE\n";
		print "CUFFCOMPARE::run    outputdir: $outputdir\n";

		my $cufflinks_jobs = [];
		foreach my $referencefile ( @referencefiles )
		{

			#### NAME OUTPUT DIR AFTER REFERENCE FILE
			my $samfile = "$outputdir/$referencefile/accepted_hits.sam";

			my $commands = [];
			my $command = $self->cuffcompareCommand($samfile);
			push @$commands, $command;

			my $label = "cuffcompare-$referencefile";
			my $outdir = "$outputdir/$referencefile";

			my $job = $self->setJob([$command], $label, $outdir);
			push @$cufflinks_jobs, $job;
		}

		#### RUN CUFFCOMPARE
		$self->runJobs($cufflinks_jobs, 'CUFFCOMPARE');

		$duration = $self->lastDuration();
		print "CUFFCOMPARE::run    ", Timer::current_datetime(), "    $duration    Completed cuffcompare\n";

	}

	#### IF chunks IS NOT DEFINED, COPY SAM FILES AND RUN CUFFCOMPARE
	else
	{
		my $samtools = $self->get_samtools();
		my $samtools_index = $self->get_samtoolsindex();

		#### 	COPY THE SAM FILES TO THE OUTPUT SUB-DIRECTORIES
		my $copysam_jobs = [];
		#### samtools view -o out.sam in.bam 
		foreach my $referencefile ( @referencefiles )
		{
			my $input_samfile = "$inputdir/$referencefile/accepted_hits.sam";
			my $samfile = "$outputdir/$referencefile/accepted_hits.sam";
			my $command = "cp $input_samfile $samfile";

			my $label = "copysam-$referencefile";
			my ($outputdir) = $input_samfile =~ /^(.+)\/[^\/]+$/; 

			my $job = $self->setJob([$command], $label, $outputdir);
			push @$copysam_jobs, $job;
		}


	#### UNCOMMENT

		print "CUFFCOMPARE::run    DOING copysam...\n";	
		#### RUN CONVERSION JOBS
		$self->runJobs($copysam_jobs);
		print "CUFFCOMPARE::run    FINISHED copysam conversion.\n";

		$duration = $self->lastDuration();
		print "CUFFCOMPARE::run    ", Timer::current_datetime(), "    $duration    Completed converting from BAM to SAM files\n";

		#### RUN CUFFCOMPARE ON THE MERGED SAM FILE FOR EACH REFERENCE
		#### TO GET EXPRESSION CALCULATIONS.
		my $cufflinks_jobs = [];
		foreach my $referencefile ( @referencefiles )
		{

			#### NAME OUTPUT DIR AFTER REFERENCE FILE
			my $samfile = "$outputdir/$referencefile/accepted_hits.sam";

			my $commands = [];
			my $command = $self->cuffcompareCommand($samfile);
			push @$commands, $command;

			my $label = "cuffcompare-$referencefile";
			my $outdir = "$outputdir/$referencefile";

			my $job = $self->setJob([$command], $label, $outdir);
			push @$cufflinks_jobs, $job;
		}

		#### RUN CUFFCOMPARE
		$self->runJobs($cufflinks_jobs, 'CUFFCOMPARE');

		$duration = $self->lastDuration();
		print "CUFFCOMPARE::run    ", Timer::current_datetime(), "    $duration    Completed running Cufflinks\n";
	}


}




=head2

	SUBROUTINE		cuffcompareCommand

	PURPOSE

		CREATE .sh FILE

=cut


sub cuffcompareCommand
{
	my $self			=	shift;
	my $samfile			=	shift;



	my ($outdir) = $samfile =~ /^(.+?)\/[^\/]+$/;

	#### USER INPUTS
	my $distance 		=	$self->get_distance();
	my $label 			=	$self->get_label();
	my $gtf 			=	$self->get_gtf();
	my $params 			=	$self->get_params();

	#### EXECUTABLES
	my $cufflinks 		=	$self->get_cufflinks();

	##### CLUSTER
	my $cpus 			=	$self->get_cpus();

	my $command = qq{
cd $outdir

time $cufflinks/cuffcompare \\
--inner-dist-mean $distance \\
--label $label \\
--num-threads $cpus \\
};

-o /scratch/syoung/base/pipeline/bixby/run1/cuffcompare/analyses9-12/9-10/cuffcompare-chr1-refseq-9-10.out \
-r /nethome/bioinfo/data/sequence/chromosomes/mouse/mm9/cufflinks/mm9-refseq-chr1.gtf \
/scratch/syoung/base/pipeline/bixby/run1/tophat/analysis9/chr1/transcripts.gtf \
/scratch/syoung/base/pipeline/bixby/run1/tophat/analysis10/chr1/transcripts.gtf


	#### ADD GTF IF DEFINED
	$command .= qq{--GTF $gtf \\\n} if defined $gtf;

	#### ADD ADDITIONAL PARAMS
	$command .= qq{$params \\\n} if defined $params;

	#### END COMMAND
	$command .= qq{$samfile\n};


	return $command;

}	#	cuffcompareCommand



################################################################################
##################			HOUSEKEEPING SUBROUTINES			################
################################################################################


=head2

	SUBROUTINE		new

	PURPOSE

		CREATE THE NEW self OBJECT AND INITIALISE IT, FIRST WITH DEFAULT 

		ARGUMENTS, THEN WITH PROVIDED ARGUMENTS

=cut

sub new
{
 	my $class 		=	shift;
	my $arguments 	=	shift;

print "CUFFCOMPARE::new    CUFFCOMPARE::new(arguments)\n";
print "CUFFCOMPARE::new    arguments:\n";
print Dumper $arguments;

	my $self = {};
    bless $self, $class;

	#### INITIALISE THE OBJECT'S ELEMENTS
	$self->initialise($arguments);

    return $self;
}



=head2

	SUBROUTINE		initialise

	PURPOSE

		INITIALISE THE self OBJECT:

			1. LOAD THE DATABASE, USER AND PASSWORD FROM THE ARGUMENTS

			2. FILL OUT %VARIABLES% IN XML AND LOAD XML

			3. LOAD THE ARGUMENTS

=cut


sub initialise
{
    my $self		=	shift;
	my $arguments	=	shift;

    #### VALIDATE USER-PROVIDED ARGUMENTS
	($arguments) = $self->validate_arguments($arguments, $DATAHASH);	

	#### LOAD THE USER-PROVIDED ARGUMENTS
	foreach my $key ( keys %$arguments )
	{		
		#### LOAD THE KEY-VALUE PAIR
		$self->value($key, $arguments->{$key});
	}

	#### HAS A QUEUE MONITOR TYPE
	if ( defined $self->{_cluster} and $self->{_cluster} eq "PBS" )
	{
		use Monitor::PBS;
	}

	if ( defined $self->{_cluster} and $self->{_cluster} eq "LSF" )
	{
		print "Doing use Monitor::LSF\n";
		require Monitor::LSF;
	}

	#### INITIALISE BATCHSTATS
	$self->{_batchstats} = [];
}


=head2

	SUBROUTINE		value

	PURPOSE

		SET A PARAMETER OF THE self OBJECT TO A GIVEN value

    INPUT

        1. parameter TO BE SET

		2. value TO BE SET TO

    OUTPUT

        1. THE SET parameter INSIDE THE BioSVG OBJECT

=cut
sub value
{
    my $self		=	shift;
	my $parameter	=	shift;
	my $value		=	shift;

	$parameter = lc($parameter);

    if ( defined $value)
	{	
		$self->{"_$parameter"} = $value;
	}
}

=head2

	SUBROUTINE		validate_arguments

	PURPOSE

		VALIDATE USER-INPUT ARGUMENTS BASED ON

		THE HARD-CODED LIST OF VALID ARGUMENTS

		IN THE data ARRAY
=cut

sub validate_arguments
{
	my $self		=	shift;
	my $arguments	=	shift;
	my $DATAHASH	=	shift;

	my $hash;
	foreach my $argument ( keys %$arguments )
	{
		if ( $self->is_valid($argument, $DATAHASH) )
		{
			$hash->{$argument} = $arguments->{$argument};
		}
		else
		{
			warn "'$argument' is not a known parameter\n";
		}
	}

	return $hash;
}


=head2

	SUBROUTINE		is_valid

	PURPOSE

		VERIFY THAT AN ARGUMENT IS AMONGST THE LIST OF

		ELEMENTS IN THE GLOBAL '$DATAHASH' HASH REF

=cut

sub is_valid
{
	my $self		=	shift;
	my $argument	=	shift;
	my $DATAHASH	=	shift;

	#### REMOVE LEADING UNDERLINE, IF PRESENT
	$argument =~ s/^_//;

	#### CHECK IF ARGUMENT FOUND IN '$DATAHASH'
	if ( exists $DATAHASH->{lc($argument)} )
	{
		return 1;
	}

	return 0;
}





=head2

	SUBROUTINE		AUTOLOAD

	PURPOSE

		AUTOMATICALLY DO 'set_' OR 'get_' FUNCTIONS IF THE

		SUBROUTINES ARE NOT DEFINED.

=cut

sub AUTOLOAD {
    my ($self, $newvalue) = @_;


    my ($operation, $attribute) = ($AUTOLOAD =~ /(get|set)(_\w+)$/);

    # Is this a legal method name?
    unless($operation && $attribute) {
        croak "Method name $AUTOLOAD is not in the recognized form (get|set)_attribute\n";
    }

    # Turn off strict references to enable "magic" AUTOLOAD speedup
    no strict 'refs';

    # AUTOLOAD accessors
    if($operation eq 'get') {

        return $self->{$attribute};


        # define subroutine
        *{$AUTOLOAD} = sub { shift->{$attribute} };

    # AUTOLOAD mutators
    }elsif($operation eq 'set') {

        # define subroutine
#        *{$AUTOLOAD} = sub { shift->{$attribute} = shift; };

        # set the new attribute value
        $self->{$attribute} = $newvalue;
    }

    # Turn strict references back on
    use strict 'refs';

    # return the attribute value
    return $self->{$attribute};
}


# When an object is no longer being used, this will be automatically called
# and will adjust the count of existing objects
sub DESTROY {
    my($self) = @_;

	#if ( defined $self->{_databasehandle} )
	#{
	#	my $dbh =  $self->{_databasehandle};
	#	$dbh->disconnect();
	#}

#    my($self) = @_;
}



1;